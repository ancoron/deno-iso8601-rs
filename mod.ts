
const str_enc = new TextEncoder();
const str_dec = new TextDecoder();

// Auto-generated with deno_bindgen
function encode(v: string | Uint8Array): Uint8Array {
  if (typeof v !== "string") return v
  return str_enc.encode(v)
}

function decode(v: Uint8Array): string {
  return str_dec.decode(v)
}

// deno-lint-ignore no-explicit-any
function readPointer(v: any): Uint8Array {
  const ptr = new Deno.UnsafePointerView(v)
  const lengthBe = new Uint8Array(4)
  const view = new DataView(lengthBe.buffer)
  ptr.copyInto(lengthBe, 0)
  const buf = new Uint8Array(view.getUint32(0))
  ptr.copyInto(buf, 4)
  return buf
}

const build_profile = Deno.env.get("BUILD_PROFILE") || "release";
const url = new URL(`./target/${build_profile}`, import.meta.url)

let uri = url.pathname
if (!uri.endsWith("/")) uri += "/"

// https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya#parameters
if (Deno.build.os === "windows") {
  uri = uri.replace(/\//g, "\\")
  // Remove leading slash
  if (uri.startsWith("\\")) {
    uri = uri.slice(1)
  }
}

const { symbols: lib } = Deno.dlopen(
  {
    darwin: uri + "libdeno_iso8601.dylib",
    windows: uri + "deno_iso8601.dll",
    linux: uri + "libdeno_iso8601.so",
    freebsd: uri + "libdeno_iso8601.so",
    netbsd: uri + "libdeno_iso8601.so",
    aix: uri + "libdeno_iso8601.so",
    solaris: uri + "libdeno_iso8601.so",
    illumos: uri + "libdeno_iso8601.so",
    android: uri + "libdeno_iso8601.so"
  }[Deno.build.os],
  {
    iso_format_millis: {
      parameters: ["i64"],
      result: "buffer",
      nonblocking: false,
    },
    iso_format_millis_fill: {
      parameters: ["i64", "buffer", "usize"],
      result: "void",
      nonblocking: false,
    },
    iso_format_millis_as_cstr: {
      parameters: ["i64"],
      result: "pointer",
      nonblocking: false,
    },
    iso_format_millis_fill_cstr: {
      parameters: ["i64", "pointer"],
      result: "u32",
      nonblocking: false,
    },
    now_iso_format: {
      parameters: [],
      result: "buffer",
      nonblocking: false,
    },
    now_iso_format_fill: {
      parameters: ["buffer", "usize"],
      result: "void",
      nonblocking: false,
    },
    now_iso_format_c: {
      parameters: [],
      result: "pointer",
      nonblocking: false,
    },
    now_iso_format_c_fill: {
      parameters: ["pointer"],
      result: "u32",
      nonblocking: false,
    },
    free_c_string: {
      parameters: ["pointer"],
      result: "void",
      nonblocking: false,
    },
  },
);

/**
 * Get an ISO-8601 representation for the given milliseconds from epoch.
 *
 * This function code was generated by deno_bindgen.
 */
export function iso_format_millis(millis: number): string {
  const rawResult = lib.iso_format_millis(BigInt(millis));
  const result = readPointer(rawResult);
  return decode(result);
}

export function iso_format_millis_fill(millis: number): string {
  const buf = new Uint8Array(24);
  lib.iso_format_millis_fill(BigInt(millis), buf, 24n);
  return str_dec.decode(buf);
}

export function iso_format_millis_as_cstr(millis: number): string {
  const ptr = lib.iso_format_millis_as_cstr(BigInt(millis));
  if (ptr === null) {
    throw new Error("Getting timestamp failed");
  }
  const str = Deno.UnsafePointerView.getCString(ptr);
  lib.free_c_string(ptr);
  return str;
}

export function iso_format_millis_fill_cstr(millis: number): string {
  const buf = new Uint8Array(25);
  const ptr = Deno.UnsafePointer.of(buf);
  lib.iso_format_millis_fill_cstr(BigInt(millis), ptr);
  return Deno.UnsafePointerView.getCString(ptr!);
}

export function now_iso_format(): string {
  const rawResult = lib.now_iso_format();
  const result = readPointer(rawResult);
  return decode(result);
}

export function now_iso_format_fill(): string {
  const buf = new Uint8Array(24);
  lib.now_iso_format_fill(buf, 24n);
  return str_dec.decode(buf);
}

export function now_iso_format_c(): string {
  const ptr = lib.now_iso_format_c();
  if (ptr === null) {
    throw new Error("Getting timestamp failed");
  }
  const str = Deno.UnsafePointerView.getCString(ptr);
  lib.free_c_string(ptr);
  return str;
}

export function now_iso_format_c_fill(): string {
  const buf = new Uint8Array(25);
  const ptr = Deno.UnsafePointer.of(buf);
  lib.now_iso_format_c_fill(ptr);
  return Deno.UnsafePointerView.getCString(ptr!);
}
